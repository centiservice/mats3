// Mats3

plugins {
    id 'java-library'
    id "com.vanniktech.maven.publish" version "0.34.0" // Publish to Maven Central, over Portal Publisher API
}

// Customize the Gradle Wrapper generation task.
wrapper {
    gradleVersion = "9.1.0"
    // Use "-all"-version of distribution, since IntelliJ works better then..
    setDistributionType(Wrapper.DistributionType.ALL)
}

allprojects {
    group = 'io.mats3'
    version = '1.0.1+2025-10-20'

    layout.getBuildDirectory().set(file("build-gradle"))
}

// Versions for all libraries used throughout the subprojects
ext {
    // :: Required for Mats3 API and implementation proper
    // (Worth pointing out that the API have NO dependencies)
    // Need the JMS API to build several modules, but ONLY on 'compileOnly' and 'testCompileOnly'!
    // It is otherwise provided by the JMS Broker implementation.
    jmsVersion = '3.1.0'     // For the JMS Impl
    slf4jVersion = '2.0.17'  // For logging throughout
    jacksonVersion = '3.0.0' // For the on-wire MatsSerializer

    // :: "Peripheral subsystems", metrics, healthcheck, SpringConfig
    // https://github.com/micrometer-metrics/micrometer/wiki/1.13-Migration-Guide
    micrometerVersion = '1.12.13' // 1.13.x have changed use of prometheus, and we need to sync.
    stbHealthCheckVersion = '0.4.1+2024-05-07' // For 'MatsEagerCacheStorebrandHealthCheck'
    // Next three for Mats SpringConfig
    springVersion = '6.2.12' // For Mats3 SpringConfig
    jakartaInjectVersion = '2.0.1'
    jakartaAnnotationVersion = '3.0.0'

    // :: For the testing tooling
    // Need a broker (one of these)
    activeMqVersion = '6.1.7'
    artemisMqVersion = '2.43.0'
    // Convenient in-jvm db for testing DataSource and DB tx.
    h2Version = '2.4.240'
    // For the JUnit testing tools - including the library tests
    junitVersion = '4.13.2'
    // For the Jupiter testing tools
    jupiterVersion = '5.14.0'
    jupiterPlatformVersion = '1.14.0'

    // :: For actually running tests (i.e. only used in testImplementation etc)
    logbackVersion = '1.5.19'
    jettyVersion = '12.1.2'
    hibernateVersion = '7.1.4.Final'
    remockVersion = '2.1.0'
    mockitoVersion = '5.20.0'
}

// :: Find which Java version to use for the toolchain.
int javaVersion = 21;
if (project.properties.containsKey('mats.build.java_version')) {
    javaVersion = Integer.parseInt((String) project.properties['mats.build.java_version'])
    println "Specified Java version for toolchain, using Java version: $javaVersion"
}

// :: Note: Two different subproject-blocks, one for all common elements, and one for publishing.

// Common for all subprojects, even 'mats-api-test'
subprojects {
    apply plugin: 'java-library'
    apply plugin: "com.vanniktech.maven.publish"

    repositories { mavenCentral() }

    java {
        sourceCompatibility = JavaVersion.VERSION_21
        targetCompatibility = JavaVersion.VERSION_21

        toolchain {
            languageVersion.set(JavaLanguageVersion.of(javaVersion))
        }
    }

    tasks.withType(JavaCompile).configureEach {
        options.encoding = 'UTF-8'
        options.incremental = true
        options.compilerArgs += ['-Werror', '-Xlint:all', '-Xlint:-serial']
        if (javaVersion >= 21) {
            options.compilerArgs += ['-Xlint:-this-escape']
        }
    }

    javadoc {
        // without the -quiet option, the build fails due to errors&warns
        options.addStringOption('Xdoclint:none', '-quiet')
        options.addStringOption('--frames')
    }

    jar {
        manifest {
            attributes 'Implementation-Title': 'Mats3',
                    'Implementation-Version': archiveVersion
        }
    }

    test {
        /*
         * All tests employ MatsTestBroker to get hold of a JMS ConnectionFactory to use for its MatsFactory creation.
         * This per default starts an in-vm ActiveMQ broker, and connects a client ActiveMQConnectionFactory to this.
         *
         * However, via system properties, you may choose which JMS client to use (activemq or artemis, and
         * you may also explicitly specify the class name of a MatsTestBroker implementation. Note: rabbitmq is not
         * supported yet), and you may specify which URL to use (with a special value "localhost" denoting the
         * client-specific way to connect to a standard broker-installation on localhost).
         *
         * Both ActiveMQ and Artemis supports in-vm creation of the broker (server) - which is the default.
         *
         * == Run all tests with in-vm ActiveMQ brokers (ActiveMQ is default, in-vm is default)
         * ./gradlew clean test
         *
         * == Run all tests with in-vm Artemis MQ brokers (Apache ActiveMQ Artemis, formerly JBoss HornetQ,
         * and what Red Hat AMQ is based upon. In-vm is default):
         * ./gradlew -Pmats.test.broker=artemis clean test
         *
         * == Run all tests against an external ActiveMQ MQ broker on localhost (ActiveMQ is default).
         * ./gradlew -Pmats.test.brokerurl=localhost clean test
         *
         * == Run all tests against an external ActiveMQ MQ broker on specific URL (ActiveMQ is default).
         * (This URL happens to be identical to specifying just "localhost" for ActiveMQ)
         * ./gradlew -Pmats.test.brokerurl="tcp://localhost:61616" clean test
         *
         * == Run all tests against an external Artemis MQ broker on localhost:
         * ./gradlew -Pmats.test.broker=artemis -Pmats.test.brokerurl=localhost clean test
         *
         * == Run with your own implementation of MatsTestBroker:
         * ./gradlew -Pmats.test.broker=com.example.MyMatsTestBrokerImpl clean test
         */
        systemProperties project.properties.subMap(["mats.test.brokerurl", "mats.test.broker"])

        // Move over the CI environment variable, so that we can increase timings of tests if on CI environment.
        // (Check MatsTestLatch.WAIT_MILLIS_FOR_NON_OCCURENCE)
        systemProperties System.getenv().subMap(["CI"])

        testLogging {
            exceptionFormat = 'full'
        }
    }

    // Also clean out some dir sometimes popping up, IntelliJ?
    clean {
        delete "$projectDir/out/"
    }

    // Define dependency report task that all subprojects gets. Invoke with "./gradlew allDeps | less"
    tasks.register('allDeps', DependencyReportTask) {}

    // :: For publishing subprojects: All, minus 'mats-api-test*'
    if (!it.name.startsWith('mats-api-test')) {
        mavenPublishing { // 'publishToMavenCentral' task.
            publishToMavenCentral()
            signAllPublications()

            coordinates(group.toString(), name, version.toString())

            pom {
                name = 'Mats^3'
                description = 'Message-based Asynchronous Transactional Staged Stateless Services'
                url = 'https://github.com/centiservice/mats3'
                licenses {
                    license {
                        name = 'The Apache License, Version 2.0'
                        url = 'https://www.apache.org/licenses/LICENSE-2.0.txt'
                    }
                }
                developers {
                    developer {
                        id = 'stolsvik'
                        name = 'Endre StÃ¸lsvik'
                        email = 'endre@stolsvik.com'
                    }
                }
                scm {
                    connection = 'scm:git:https://github.com/stolsvik/mats.git'
                    developerConnection = 'scm:git:ssh://github.com:centiservice/mats3.git'
                    url = 'https://github.com/centiservice/mats3'
                }
            }
        }
    }
}

clean {
    // Vanniktech publish plugin creates this, so clean it too.
    delete "build/"
    // Note: "build-gradle" pops back up after any gradle run, as config cache and problem report puts things there.
}

// For "all JavaDoc" task, sweeping together all sources to make a complete set of JavaDoc in one go.
// - Adapted from https://coderwall.com/p/evtdbw/aggregate-javadoc-in-multiproject-gradle-builds
apply plugin: 'java'
tasks.register('alljavadoc', Javadoc) {
    def relevantProjects = subprojects.findAll { ! it.name.startsWith('mats-api-test') }
    source relevantProjects.collect { it.sourceSets.main.allJava }
    classpath = files(relevantProjects.collect { it.sourceSets.main.compileClasspath })
    destinationDir = file("${layout.buildDirectory}/docs/javadoc")
    options.addStringOption('Xdoclint:none', '-quiet')
    options.addStringOption('--frames')
}
// .. ensure 'alljavadoc' is run together with './gradlew clean javadoc', thus building 'all' + submodules.
javadoc.dependsOn alljavadoc

// ------------------------------------------------
// -- Simple tools

// Some info about current gradle environment.
import java.nio.charset.Charset
tasks.register('systemInformation') {
    def gradleVersion = gradle.gradleVersion // Needed due to config cache.
    doLast {
        println "\n** Java properties [System.getProperties()], sorted:\n"
        System.properties.sort().each { k, v ->
            println("$k = $v")
        }
        println "\n** Environment [System.getenv()], sorted:\n"
        System.env.sort().each { k, v ->
            println("$k = $v")
        }
        println ''
        println "** Charset.defaultCharset(): " + Charset.defaultCharset()
        println ''
        println "** Java Version:   " + System.getProperty("java.version")
        println "** Groovy Version: " + GroovySystem.getVersion()
        println "** Gradle Version: " + gradleVersion
    }
}
