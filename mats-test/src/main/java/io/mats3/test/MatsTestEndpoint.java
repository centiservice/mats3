/*
 * Copyright 2015-2025 Endre St√∏lsvik
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mats3.test;

import java.util.List;

import io.mats3.MatsEndpoint.DetachedProcessContext;
import io.mats3.MatsEndpoint.MatsRefuseMessageException;
import io.mats3.MatsEndpoint.ProcessContext;
import io.mats3.MatsEndpoint.ProcessSingleLambda;
import io.mats3.MatsEndpoint.ProcessTerminatorLambda;
import io.mats3.MatsFactory;
import io.mats3.MatsInitiator.MatsInitiate;

/**
 * Test-utility: Interface for a test endpoint which can be used to verify that a message was sent to the endpoint, and
 * to retrieve the incoming message and its state, and its {@link DetachedProcessContext} (to e.g. get sideloads). To
 * get instances of this interface, use the JUnit 4 Rule {@code Rule_MatsTestEndpoints} or the JUnit 5 (Jupiter)
 * Extension {@code Extension_MatsTestEndpoints}.
 *
 * @param <R>
 *            The reply class of the message generated by this endpoint.
 * @param <S>
 *            The state class of the endpoint.
 * @param <I>
 *            The incoming message class for this endpoint.
 */
public interface MatsTestEndpoint<R, S, I> {
    MatsTestEndpoint<R, S, I> setMatsFactory(MatsFactory matsFactory);

    void verifyNotInvoked();

    Message<S, I> awaitInvocation();

    Message<S, I> awaitInvocation(long millisToWait);

    List<Message<S, I>> awaitInvocations(int expectedNumberOfIncomingMsgs);

    List<Message<S, I>> awaitInvocations(int expectedNumberOfIncomingMsgs, long millisToWait);

    interface Message<S, I> {
        DetachedProcessContext getContext();

        S getState();

        I getData();
    }

    /**
     * Mock endpoint which processes an incoming message and returns a reply. Ideal for mocking intermediate endpoints
     * in a multi-stage flow whether they are internal to the application or external.
     * <p>
     * If no processor is defined this will function as a {@link ITerminator}, thus one should consider using that
     * instead if one ends up in a test situation where the processor is never defined.
     *
     * @param <R>
     *            The reply class of the message generated by this endpoint.
     * @param <I>
     *            The incoming message class for this endpoint.
     */
    interface IEndpoint<R, I> extends MatsTestEndpoint<R, Void, I> {
        /**
         * Specify the processing lambda to be executed by the endpoint aka the endpoint logic. This is typically
         * invoked either inside a test method to setup the behavior for that specific test or once through the initial
         * setup when creating the test endpoint.
         *
         * @param processLambda
         *            which the endpoint should execute on an incoming request.
         */
        IEndpoint<R, I> setProcessLambda(ProcessSingleLambda<R, I> processLambda);

        /**
         * Sets the internal {@link MatsFactory} to be utilized for the creation of this endpoint.
         * <p>
         * If not utilized explicitly can also be injected/autowired through the use of the test execution listener
         * <code>@SpringInjectRulesAndExtensions</code> should this Rule be utilized in a test where a Spring context is
         * in play.
         *
         * @param matsFactory
         *            to set.
         * @return this instance of the object.
         */
        @Override
        IEndpoint<R, I> setMatsFactory(MatsFactory matsFactory);
    }

    /**
     * Equivalent to {@link IEndpoint}, but allows for the definition of a state class. Thus, can be utilized to
     * validate the passed state for flows which spin off new MATS^3 flows and seeds the state of the target endpoint
     * through the use of {@link MatsInitiate#send(Object, Object)}.
     *
     * @param <R>
     *            The reply class of the message generated by this endpoint.
     * @param <S>
     *            The state class of the endpoint.
     * @param <I>
     *            The incoming message class for this endpoint.
     */
    interface IEndpointWithState<R, S, I> extends MatsTestEndpoint<R, S, I> {
        /**
         * Specify the processing lambda to be executed by the endpoint aka the endpoint logic. This is typically
         * invoked either inside a test method to setup the behavior for that specific test or once through the initial
         * setup when creating the test endpoint.
         *
         * @param processLambda
         *            which the endpoint should execute on an incoming request.
         */
        IEndpointWithState<R, S, I> setProcessLambda(ProcessSingleStateLambda<R, S, I> processLambda);

        /**
         * Sets the internal {@link MatsFactory} to be utilized for the creation of this endpoint.
         * <p>
         * If not utilized explicitly can also be injected/autowired through the use of the test execution listener
         * <code>@SpringInjectRulesAndExtensions</code> should this Rule be utilized in a test where a Spring context is
         * in play.
         *
         * @param matsFactory
         *            to set.
         * @return this instance of the object.
         */
        @Override
        IEndpointWithState<R, S, I> setMatsFactory(MatsFactory matsFactory);
    }

    @FunctionalInterface
    interface ProcessSingleStateLambda<R, S, I> {
        R process(ProcessContext<R> ctx, S state, I msg) throws MatsRefuseMessageException;
    }

    /**
     * Simplified version of {@link IEndpoint}, which doesn't require the specification of a return class. Useful for
     * scenarios where one is only interested in the incoming message and has no need for processor.
     *
     * @param <I>
     *            The incoming message class for this endpoint.
     */
    interface ITerminator<I> extends MatsTestEndpoint<Void, Void, I> {
        /**
         * Specify the processing lambda to be executed by the endpoint aka the endpoint logic. This is typically
         * invoked either inside a test method to setup the behavior for that specific test or once through the initial
         * setup when creating the test endpoint.
         *
         * @param processLambda
         *            which the endpoint should execute on an incoming request.
         */
        ITerminator<I> setProcessLambda(ProcessTerminatorNoStateLambda<I> processLambda);

        /**
         * Sets the internal {@link MatsFactory} to be utilized for the creation of this endpoint.
         * <p>
         * If not utilized explicitly can also be injected/autowired through the use of the test execution listener
         * <code>@SpringInjectRulesAndExtensions</code> should this Rule be utilized in a test where a Spring context is
         * in play.
         *
         * @param matsFactory
         *            to set.
         * @return this instance of the object.
         */
        @Override
        ITerminator<I> setMatsFactory(MatsFactory matsFactory);
    }

    @FunctionalInterface
    interface ProcessTerminatorNoStateLambda<I> {
        void process(ProcessContext<Void> ctx, I msg) throws MatsRefuseMessageException;
    }

    /**
     * Expanded version of {@link ITerminator}, which also allows for the specification of a state class.
     *
     * @param <S>
     *            The state class of the endpoint.
     * @param <I>
     *            The incoming message class for this endpoint.
     */
    interface ITerminatorWithState<S, I> extends MatsTestEndpoint<Void, S, I> {
        /**
         * Specify the processing lambda to be executed by the endpoint aka the endpoint logic. This is typically
         * invoked either inside a test method to setup the behavior for that specific test or once through the initial
         * setup when creating the test endpoint.
         *
         * @param processLambda
         *            which the endpoint should execute on an incoming request.
         */
        ITerminatorWithState<S, I> setProcessLambda(ProcessTerminatorLambda<S, I> processLambda);

        /**
         * Sets the internal {@link MatsFactory} to be utilized for the creation of this endpoint.
         * <p>
         * If not utilized explicitly can also be injected/autowired through the use of the test execution listener
         * <code>@SpringInjectRulesAndExtensions</code> should this Rule be utilized in a test where a Spring context is
         * in play.
         *
         * @param matsFactory
         *            to set.
         * @return this instance of the object.
         */
        @Override
        ITerminatorWithState<S, I> setMatsFactory(MatsFactory matsFactory);
    }
}
