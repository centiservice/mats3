/*
 * Copyright 2015-2025 Endre Stølsvik
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.mats3.test.abstractunit;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.mats3.MatsEndpoint;
import io.mats3.MatsEndpoint.DetachedProcessContext;
import io.mats3.MatsEndpoint.ProcessContext;
import io.mats3.MatsEndpoint.ProcessSingleLambda;
import io.mats3.MatsEndpoint.ProcessTerminatorLambda;
import io.mats3.MatsFactory;
import io.mats3.test.MatsTestEndpoint.IEndpoint;
import io.mats3.test.MatsTestEndpoint.IEndpointWithState;
import io.mats3.test.MatsTestEndpoint.Message;
import io.mats3.test.MatsTestEndpoint.ProcessSingleStateLambda;
import io.mats3.test.MatsTestEndpoint.ProcessTerminatorNoStateLambda;

/**
 * Common base class which consolidates the common logic utilized by both Rule_MatsEndpoint and Extension_MatsEndpoint.
 * <ul>
 * <li>mats-test-junit</li>
 * <li>mats-test-jupiter</li>
 * </ul>
 * <p>
 * Sets up a {@link MatsEndpoint} which processor can be modified on the fly. Also provides utility methods to extract
 * incoming requests and verify that endpoint har or hasn't been invoked.
 *
 * @param <R>
 *            The reply class of the message generated by this endpoint. (Reply Class)
 * @param <I>
 *            The incoming message class for this endpoint. (Request Class)
 * @author Kevin Mc Tiernan, 2020-10-22, kmctiernan@gmail.com
 * @author Geir Gullestad Pettersen, 2017 - geirgp@gmail.com
 * @author Johan Herman Hausberg, 2017.04 - jhausber@gmail.com
 * @author Asbjørn Aarrestad, 2017 - asbjorn@aarrestad.com
 * @author Endre Stølsvik, 2017 - http://stolsvik.com/, endre@stolsvik.com
 */
public abstract class AbstractMatsTestEndpoint<R, S, I> {

    private static final Logger log = LoggerFactory.getLogger(AbstractMatsTestEndpoint.class);

    /** Actual {@link MatsEndpoint} returned from the {@link MatsFactory} during creation. */
    protected MatsEndpoint<R, S> _endpoint;

    private final String _endpointId;
    private final Class<R> _replyMsgClass;
    private final Class<S> _stateClass;
    private final Class<I> _incomingMsgClass;

    protected MatsFactory _matsFactory;
    protected volatile Object _processLambda;

    /**
     * Synchronized list keeping track of all endpoint invocations, storing the incoming message for later retrieval.
     */
    protected final SynchronizedInvocationList<S, I> _synchronizedInvocationList = new SynchronizedInvocationList<>();

    /**
     * Default time out in milliseconds, 30 seconds.
     *
     * @see #waitForRequest()
     * @see #waitForRequests(int)
     * @see #awaitInvocation()
     * @see #awaitInvocations(int)
     */
    private static final int DEFAULT_TIME_OUT_MILLIS = 30_000;

    /**
     * Base constructor for {@link AbstractMatsTestEndpoint}, takes all values needed to set up the test endpoint.
     *
     * @param endpointId
     *            Identifier of the endpoint being created.
     * @param replyMsgClass
     *            Class of the reply message.
     * @param incomingMsgClass
     *            Class of the incoming message. (Request)
     */
    protected AbstractMatsTestEndpoint(String endpointId, Class<R> replyMsgClass, Class<S> stateClass,
            Class<I> incomingMsgClass) {
        _endpointId = endpointId;
        _replyMsgClass = replyMsgClass;
        _stateClass = stateClass;
        _incomingMsgClass = incomingMsgClass;
    }

    /**
     * Blocks and waits for the endpoint to be invoked, then returns the incoming message DTO of the type
     * (<code>I</code>). Will use a default timout value of 30 seconds.
     * <p>
     * Should one want to verify something within the context e.g. side-loads or incoming state (not always applicable),
     * consider utilizing {@link #awaitInvocation}.
     *
     * @return the first incoming message it encounters after calling this method.
     * @see #awaitInvocation()
     */
    protected I waitForRequest() {
        return waitForRequest(DEFAULT_TIME_OUT_MILLIS);
    }

    /**
     * Blocks and waits for the endpoint to be invoked, then returns the incoming message DTO of the type
     * (<code>I</code>).
     * <p>
     * Should one want to verify something within the context e.g. side-loads or incoming state (not always applicable),
     * consider utilizing {@link #awaitInvocation}.
     *
     * @param millisToWait
     *            time to wait before timing out.
     * @return the first incoming message it encounters after calling this method.
     * @see #awaitInvocation(long)
     */
    protected I waitForRequest(long millisToWait) {
        return waitForRequests(1, millisToWait).get(0);
    }

    /**
     * Blocks and waits for the endpoint to be invoked x number of times, then returns the x number of corresponding
     * incoming message DTO's of the type (<code>I</code>). Will utilize a default timeout value of 30 seconds.
     * <p>
     * Should one want to verify something within the context e.g. side-loads or incoming state (not always applicable),
     * consider utilizing {@link #awaitInvocations}.
     *
     * @param expectedNumberOfIncomingMsgs
     *            the number of incoming messages before unblocking and returning the received objects.
     * @return the x number of incoming message it encounters after calling this method as a List&lt;I&gt;.
     * @see #awaitInvocations(int)
     */
    protected List<I> waitForRequests(int expectedNumberOfIncomingMsgs) {
        return waitForRequests(expectedNumberOfIncomingMsgs, DEFAULT_TIME_OUT_MILLIS);
    }

    /**
     * Blocks and waits for the endpoint to be invoked x number of times, then returns the x number of corresponding
     * incoming message DTO's of the type (<code>I</code>).
     * <p>
     * Should one want to verify something within the context e.g. side-loads or incoming state (not always applicable),
     * consider utilizing {@link #awaitInvocations}.
     *
     * @param expectedNumberOfIncomingMsgs
     *            the number of incoming messages before unblocking and returning the received objects.
     * @param millisToWait
     *            time to wait before timing out.
     * @return the x number of incoming message it encounters after calling this method as a List&lt;I&gt;.
     * @see #awaitInvocations(int, long)
     */
    protected List<I> waitForRequests(int expectedNumberOfIncomingMsgs, long millisToWait) {
        return _synchronizedInvocationList.getInvocationsWaitForCount(expectedNumberOfIncomingMsgs, millisToWait,
                _endpointId).stream()
                .map(Message::getData)
                .collect(Collectors.toList());
    }

    /**
     * Blocks and waits for the endpoint to be invoked, then returns a {@link Message} containing the context, incoming
     * state (<code>S</code>) and incoming message (<code>I</code>). Will use a default timout value of 30 seconds.
     *
     * @return {@link Message}
     */
    protected Message<S, I> awaitInvocation() {
        return awaitInvocation(DEFAULT_TIME_OUT_MILLIS);
    }

    /**
     * Blocks and waits for the specified amount of time for the endpoint to be invoked, then returns a {@link Message}
     * containing the context, incoming state (<code>S</code>) and incoming message (<code>I</code>).
     *
     * @param millisToWait
     *            before timing out.
     * @return {@link Message}
     */
    protected Message<S, I> awaitInvocation(long millisToWait) {
        return awaitInvocations(1, millisToWait).get(0);
    }

    /**
     * Blocks and waits for the endpoint to be invoked x number of times, then returns the x number of {@link Message}
     * containing the context, incoming state (<code>S</code>) and incoming message (<code>I</code>). Will utilize a
     * default timeout value of 30 seconds.
     *
     * @param expectedNumberOfIncomingMsgs
     *            the number of incoming messages before unblocking and returning the {@link Message}s.
     * @return List of {@link Message Result}.
     */
    protected List<Message<S, I>> awaitInvocations(int expectedNumberOfIncomingMsgs) {
        return awaitInvocations(expectedNumberOfIncomingMsgs, DEFAULT_TIME_OUT_MILLIS);
    }

    /**
     * Blocks and waits the specified amount of time for the endpoint to be invoked x number of times, then returns the
     * x number of {@link Message} containing the context, incoming state (<code>S</code>) and incoming message
     * (<code>I</code>).
     *
     * @param expectedNumberOfIncomingMsgs
     *            the number of incoming messages before unblocking and returning the {@link Message}s.
     * @param millisToWait
     *            before timing out.
     * @return List of {@link Message Result}.
     */
    protected List<Message<S, I>> awaitInvocations(int expectedNumberOfIncomingMsgs, long millisToWait) {
        return _synchronizedInvocationList.getInvocationsWaitForCount(expectedNumberOfIncomingMsgs, millisToWait,
                _endpointId);
    }

    /**
     * Verifies that this endpoint has not been invoked. This can be useful in scenarios where an endpoint has multiple
     * routes x,y and z. For example, given request A, the request should be processed and forwarded to y endpoint and
     * this endpoint should not be invoked.
     *
     * @throws UnexpectedMatsTestEndpointInvocationError
     *             exception thrown if the endpoint has been invoked.
     */
    public void verifyNotInvoked() {
        // Wait 25 ms as per JavaDoc contract
        try {
            Thread.sleep(25);
        }
        catch (InterruptedException e) {
            throw new RuntimeException("Interrupted while chilling before checking that no messages has arrived.", e);
        }
        // ?: Has there been any invocations of the endpoint?
        if (_synchronizedInvocationList.hasInvocations()) {
            // -> Yes, this was not expected as per invocation of this method. Throw hard.
            throw new UnexpectedMatsTestEndpointInvocationError(_endpointId,
                    _synchronizedInvocationList.getNumberOfInvocations());
        }
        // ?: Has the process lambda possibly thrown an exception?
        Throwable exceptionRaisedByProcessLambda = _synchronizedInvocationList.getExceptionRaisedByProcessLambda();
        if (exceptionRaisedByProcessLambda != null) {
            // -> Yes, this was not expected as per invocation of this method. Throw hard.
            throw new ProcessLambdaFailedError(_endpointId, exceptionRaisedByProcessLambda);
        }
        // E-> All good! Drift away...
    }

    // ======================== JUnit Lifecycle methods ===============================================================

    private boolean isJunit() {
        return getClass().getName().contains(".junit.");
    }

    private String junitOrJupiter() {
        return isJunit() ? "JUnit" : "Jupiter";
    }

    protected String idThis() {
        return this.getClass().getSimpleName() + "@" + Integer.toHexString(System.identityHashCode(this));
    }

    /**
     * Registers a {@link MatsEndpoint} with the provided {@link MatsFactory}, notice that the {@link MatsFactory} is
     * not set or provided directly through this class through the use of the constructor or a method. It is up to the
     * extending class to provide this factory.
     * <p>
     * The created endpoint is created as a {@link MatsFactory#staged} endpoint, the reason behind this is that a staged
     * endpoint does not require a return unlike a {@link MatsFactory#single}.
     * <p>
     * This method should be called as a result of the following life cycle events for either JUnit or Jupiter:
     * <ul>
     * <li>Before - JUnit - Rule</li>
     * <li>BeforeEachCallback - Jupiter</li>
     * </ul>
     */
    public void before() {
        log.debug("+++ " + junitOrJupiter() + " +++ BEFORE on '" + idThis() + "'.");

        // ?: Is the mats factory defined?
        if (_matsFactory == null) {
            // -> No, then we can't continue. Throw hard.
            String testExecutionListener = isJunit()
                    ? "SpringInjectRulesTestExecutionListener"
                    : "SpringInjectExtensionsTestExecutionListener";
            throw new MatsFactoryNotSetException("== " + getClass().getSimpleName() + " == : MatsFactory is"
                    + " not set, thus cannot complete setup of test endpoint.\n Provide me a MatsFactory either through"
                    + " setting it explicitly through setMatsFactory(...), or if in a Spring testing context, annotate"
                    + " your test class with '@SpringInjectRulesAndExtensions', or if that fails, "
                    + " '@TestExecutionListeners(listeners = " + testExecutionListener
                    + ".class, mergeMode = MergeMode.MERGE_WITH_DEFAULTS)' to inject it from the Spring Context.");
        }

        // Register a generic "staged" endpoint, with only one stage, to handle the different types of MatsTestEndpoint.
        _endpoint = _matsFactory.staged(_endpointId, _replyMsgClass, _stateClass);

        _endpoint.stage(_incomingMsgClass, (ctx, state, msg) -> {
            try {
                // ?: Has a processor been defined?
                if (_processLambda != null) {
                    // -> Yes, then we should execute the processor.
                    log.debug("+++ [" + _endpointId + "] executing user defined process lambda, incoming message"
                            + " class:[" + (msg != null ? msg.getClass().getSimpleName() : "{null msg}")
                            + "], expected reply class: [" + _replyMsgClass + "]");
                    if (_processLambda instanceof ProcessSingleLambda) {
                        @SuppressWarnings("unchecked")
                        ProcessSingleLambda<R, I> processSingleLambda = (ProcessSingleLambda<R, I>) _processLambda;
                        ctx.reply(processSingleLambda.process(ctx, msg));
                    }
                    else if (_processLambda instanceof ProcessSingleStateLambda) {
                        @SuppressWarnings("unchecked")
                        ProcessSingleStateLambda<R, S, I> processTerminator = (ProcessSingleStateLambda<R, S, I>) _processLambda;
                        ctx.reply(processTerminator.process(ctx, state, msg));
                    }
                    else if (_processLambda instanceof ProcessTerminatorNoStateLambda) {
                        @SuppressWarnings("unchecked")
                        ProcessTerminatorNoStateLambda<I> processTerminator = (ProcessTerminatorNoStateLambda<I>) _processLambda;
                        // No reply, so we'll need to cast the ProcessContext to a Void.
                        @SuppressWarnings("unchecked")
                        ProcessContext<Void> ctxVoid = (ProcessContext<Void>) ctx;
                        processTerminator.process(ctxVoid, msg);
                    }
                    else if (_processLambda instanceof ProcessTerminatorLambda) {
                        @SuppressWarnings("unchecked")
                        ProcessTerminatorLambda<S, I> processTerminator = (ProcessTerminatorLambda<S, I>) _processLambda;
                        // No reply, so we'll need to cast the ProcessContext to a Void.
                        @SuppressWarnings("unchecked")
                        ProcessContext<Void> ctxVoid = (ProcessContext<Void>) ctx;
                        processTerminator.process(ctxVoid, state, msg);
                    }
                    else {
                        throw new AssertionError("Don't know this process lambda type: " + _processLambda.getClass()
                                + ": " + _processLambda);
                    }
                }
                else {
                    // -> No, then we should not reply.
                    log.debug("+++ [" + _endpointId + "] no process lambda defined, thus not replying.");
                }

                // :: Use Mats3's ability to perform an additional operation AFTER the processing/send/commit is done.
                // Add the invocation to the invocation list.
                ctx.doAfterCommit(() -> {
                    _synchronizedInvocationList.addInvocation(new Message<>() {
                        @Override
                        public DetachedProcessContext getContext() {
                            return ctx;
                        }

                        @Override
                        public S getState() {
                            return state;
                        }

                        @Override
                        public I getData() {
                            return msg;
                        }
                    });
                });
            }
            catch (Throwable t) {
                // :: Catch all exceptions (from process lambdas defined in test code).
                // Log
                log.error("+++ [" + _endpointId + "] caught exception in process lambda: " + t.getMessage(), t);
                // Fail the synchronized invocation list, so that it will fail on any of the "await" methods.
                _synchronizedInvocationList.exceptionRaisedByProcessLambda(t);
                // Otherwise ignore, i.e. don't try to reply or anything - this will stop the Mats Flow, and possibly
                // fail the test in other ways than on the await - but there's at least an ERROR logline in that case.
            }
        });

        // For a multi-stage, the invocation of lastStage() executes the finishSetup() however since we only utilize one
        // stage with no last stage we need to explicitly call finishSetup() for the endpoint to start.
        _endpoint.finishSetup();
        log.debug("--- " + junitOrJupiter() + " --- /BEFORE done on '" + idThis() + "'.");
    }

    /**
     * Shutdown and remove the endpoint from the {@link MatsFactory} after test and remove reference to endpoint from
     * field.
     * <p>
     * This method should be called as a result of the following life cycle events for either JUnit or Jupiter:
     * <ul>
     * <li>After - JUnit - Rule</li>
     * <li>AfterEachCallback - Jupiter</li>
     * </ul>
     */
    public void after() {
        log.debug("+++ " + junitOrJupiter() + " +++ AFTER on '" + idThis() + "'.");
        Optional<MatsEndpoint<?, ?>> endpoint = _matsFactory.getEndpoint(_endpointId);
        endpoint.ifPresent(ep -> ep.remove(30_000));
        _endpoint = null;
        _synchronizedInvocationList.reset();
        log.debug("--- " + junitOrJupiter() + " --- /AFTER done on '" + idThis() + "'.");
    }

    // =============== Util :: Synchronizer ===========================================================================

    /**
     * Util to keep a list of invocations and the ability to {@link Object#wait(long)} for a number of invocations with
     * a timeout.
     * <p>
     * Expected usage of class is multiple threads accessing {@link #addInvocation} and one test thread accessing either
     * {@link #getInvocationsWaitForCount(int, long, String)} or {@link #hasInvocations()}.
     *
     * @param <I>
     *            The class type of the incoming message object to be stored within the {@link Message} in the internal
     *            list.
     * @param <S>
     *            The class type of the incoming state object to be stored within the {@link Message} in the internal
     *            list.
     */
    static class SynchronizedInvocationList<S, I> {
        private final Object _lock = new Object();
        private final List<Message<S, I>> _invocations = new ArrayList<>();
        private Throwable _exceptionRaisedByProcessLambda;

        /**
         * Blocks and waits for the {@link #_invocations invocations list} to contain the given count number of
         * elements. Given that the list is filled up with the desired number of elements within the specified timeout
         * period, it will return these elements. Should the number of elements not reach the specified count it will
         * timeout and throw an {@link AssertionError}.
         *
         * @param count
         *            number of invocations to wait for.
         * @param timeoutMillis
         *            milliseconds to wait before timing out.
         * @param endpointId
         *            the endpointId of the endpoint being tested.
         * @return the number of count specified objects as a List&lt;I&gt;.
         * @throws AssertionError
         *             if the expected number of invocations has not been received before timing out.
         */
        List<Message<S, I>> getInvocationsWaitForCount(int count, long timeoutMillis, String endpointId) {
            synchronized (_lock) {

                // StartTime representing when we entered this method.
                long startTime = System.currentTimeMillis();

                try {
                    // Loop until we have the desired number of invocations.
                    while (_invocations.size() < count) {
                        // ?: Has the process lambda raised an exception during our waiting?
                        if (_exceptionRaisedByProcessLambda != null) {
                            // -> Yes, so then we don't care about any invocations, we just want to fail the test.
                            throw new ProcessLambdaFailedError(endpointId, _exceptionRaisedByProcessLambda);
                        }

                        // How long since we first entered this method?
                        long elapsedTime = System.currentTimeMillis() - startTime;

                        // The reason we use remaining timeout is that we want to throw after timeout milliseconds and
                        // not count * timeout milliseconds. If count is 100, timeout is 5s and the code has become slow
                        // as hell (4s pr invocation), this method would otherwise not have thrown until 400s
                        long remainingTimeout = timeoutMillis - elapsedTime;

                        // Object::wait() doesn't throw when it times out (it only returns), so we need to check the
                        // timeout ourselves.
                        if (remainingTimeout <= 0) {
                            throw new AssertionError("+++ Expected [" + count + "] invocations, "
                                    + "but got [" + _invocations.size() + "] during the [" + timeoutMillis + "] timeout"
                                    + "window.");
                        }

                        // The other method will wake us up every time there is a new invocation
                        _lock.wait(remainingTimeout);
                    }
                }
                catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }

                // ?: Has the process lambda raised an exception?
                if (_exceptionRaisedByProcessLambda != null) {
                    // -> Yes, so then we don't care about any invocations, we just want to fail the test.
                    throw new ProcessLambdaFailedError(endpointId, _exceptionRaisedByProcessLambda);
                }

                // ----- When the loop exits we know that the desired number of invocations has been reached, and no
                // exception has occurred in the process lambda.
                // Copy off the list before returning.
                return new ArrayList<>(_invocations);
            }
        }

        void addInvocation(Message<S, I> invocation) {
            synchronized (_lock) {
                _invocations.add(invocation);
                _lock.notifyAll();
            }
        }

        void reset() {
            synchronized (_lock) {
                _invocations.clear();
                _exceptionRaisedByProcessLambda = null;
                _lock.notifyAll();
            }
        }

        /**
         * @return the number of elements in the internal {@link #_invocations invocations list}.
         */
        int getNumberOfInvocations() {
            synchronized (_lock) {
                return _invocations.size();
            }
        }

        /**
         * @return <code>true</code> if the underlying {@link #_invocations} list contains an entry, else
         *         <code>false</code>.
         */
        boolean hasInvocations() {
            synchronized (_lock) {
                return !_invocations.isEmpty();
            }
        }

        Throwable getExceptionRaisedByProcessLambda() {
            synchronized (_lock) {
                return _exceptionRaisedByProcessLambda;
            }
        }

        void exceptionRaisedByProcessLambda(Throwable t) {
            synchronized (_lock) {
                _exceptionRaisedByProcessLambda = t;
                _lock.notifyAll();
            }
        }
    }

    // =========== Exceptions =========================================================================================

    /**
     * Thrown by {@link #verifyNotInvoked} should the internal {@link #_synchronizedInvocationList} contain any elements
     * indicating an invocation.
     */
    static final class UnexpectedMatsTestEndpointInvocationError extends AssertionError {
        public UnexpectedMatsTestEndpointInvocationError(String endpointId, int numberOfInvocations) {
            super("Unexpected invocation of MatsEndpoint with id [" + endpointId + "]. The endpoint was"
                    + " invoked [" + numberOfInvocations + "] times.");
        }
    }

    /**
     * Thrown if the test-defined process lambda throws an exception.
     */
    static final class ProcessLambdaFailedError extends AssertionError {
        public ProcessLambdaFailedError(String endpointId, Throwable t) {
            super("The specified ProcessLambda for MatsTestEndpoint [" + endpointId + "] raised a '"
                    + t.getClass().getSimpleName() + "' when it received a message: " + t.getMessage(), t);
        }
    }

    /**
     * Thrown should the {@link #before()} be called without a {@link MatsFactory} be provided.
     */
    static final class MatsFactoryNotSetException extends RuntimeException {
        public MatsFactoryNotSetException(String msg) {
            super(msg);
        }
    }

    /**
     * Thrown if an {@link IEndpoint} or {@link IEndpointWithState} has not had its process lambda set when awaiting
     * invocations.
     */
    protected static final class ProcessLambdaNotSetException extends IllegalStateException {
        public ProcessLambdaNotSetException(String msg) {
            super(msg);
        }
    }
}
